## 일일보고_연구일지_김민수_2026_01_27

### 주요 항목 요약

- **카테고리 불릿 품질 고도화 1차 완료**  
  - `ai_report_bullets_lib.py`에서 카테고리 요약 불릿을 **UI용 고정 템플릿(8줄 내외, 순서 고정)** 으로 정규화  
  - 리뷰 분포/가격 분위수/상위 브랜드·채널·키워드 등 근거를 명시하는 문장 톤으로 통일
- **세그먼트(유망 세그먼트) 추출 로직 도입**  
  - `specifications` / `unit_price`에서 연령대·구성·용량·타입 등을 파싱해 `top_segments`로 집계, 유망 세그먼트 1줄 추가 가능 구조 완성
- **학습 데이터 대폭 확장 & LoRA v3 / v4 재학습 완료**  
  - 카테고리 4개 × 샘플 15개 → 60개(v3), 이후 50개 → 200개(v4)로 확장  
  - 학습 손실: v2(1.11) → v3(0.65) → v4(0.23)까지 개선
- **추론 파이프라인 안정화(모델+템플릿 하이브리드)**  
  - 모델 출력이 JSON 스키마를 어기면 자동으로 템플릿 불릿으로 폴백하도록 구성  
  - 현재 실제 출력은 템플릿이 담당하되, 모델 출력은 디버깅/향후 품질 고도화용으로 로그 남김

---

### 작업 내용 요약

#### 1) 불릿 템플릿/표현 품질 고도화

- `ai_report_bullets_lib.py`의 `build_category_summary_bullets` 를 중심으로 **고정 순서 템플릿** 정리
  - 규모 → 포화/검증 → 만족도/리스크 → 가격대/추이 → 채널 → 경쟁구도(브랜드) → 유망 세그먼트 → 키워드 → 업데이트 기간
- 각 문장에 근거를 명시하는 표현으로 통일
  - 예:  
    - “리뷰 0건 상품 비중은 …입니다.”  
    - “누적 리뷰 기준 가중 평균 평점은 …입니다.”  
    - “리뷰 분포 기준 상위 채널은 …입니다.”  
    - “가격 분위수 P25~P75: …” 등
- 세그먼트 문장을 위한 포맷 정의  
  - 연령/구성/타입/용량 등의 세그먼트를 자연스러운 한국어 문장으로 나열하는 로직 설계

---

#### 2) 세그먼트 추출 및 집계 로직 구현

- `CategoryMetrics` 에 `top_segments: List[Tuple[str, int]]` 필드 추가
- `ai_report_bullets_lib.py` 내에 세그먼트 관련 유틸 추가
  - `_extract_segments_from_specs`  
    - `specifications` 유사 딕셔너리/문자열에서 연령(예: 3세 이상), 용량(ml, g), 구성(세트/리필 등), 타입(에센스/크림 등) 키워드 파싱
  - `_extract_segments_from_unit_price`  
    - `unit_price` 컬럼에서 단위(매당/포당/개당 등)를 추출
  - `_aggregate_segments`  
    - 위 두 함수를 카테고리 단위로 돌려 세그먼트를 카운트하고, 일정 빈도 이상인 상위 항목만 `top_segments` 로 정리
- `aggregate_category` 에서 `top_segments`를 함께 집계하도록 수정 → 템플릿 & SFT 학습 양쪽에서 사용 가능

---

#### 3) SFT 학습 데이터 확장 (4개 카테고리 → 60 → 200 샘플)

- `19_prepare_category_bullet_sft.py` 개선
  - 인자 추가
    - `--samples_per_category` (기본 15 → 실행 시 50까지 확장)  
    - `--subsample_ratio` (기본 0.85, 실행 시 0.8 사용)  
    - `--seed` (기본 42)
  - 각 카테고리 그룹 `g`에서
    - `samples_per_category` 만큼 반복하며 `subsample_ratio` 비율로 서브샘플링 (`g.sample(...)`)  
    - 각 서브샘플에 대해 `aggregate_category` → `build_category_summary_bullets` 로 (입력, 타깃) 페어 생성
- 결과
  - 초기: 4개 카테고리 × 1샘플 = 4 examples  
  - 1차 확장(v3): 4 × 15 = 60 examples  
  - 2차 확장(v4): 4 × 50 = 200 examples
- 시스템 프롬프트 정교화
  - 출력이 **반드시** `{"summaryBullets":["문장", ...]}` 구조가 되도록  
  - 필드명 `'summaryBullets'`(복수형) 강제, `'summaryBulleted'` 등 다른 이름 금지  
  - `summaryBullets` 는 문자열 리스트여야 하고, 단일 문자열/객체 금지

---

#### 4) LoRA 재학습(v3, v4) 및 학습 품질

- v3 학습 (`results_bullets/qwen2.5-3b-lora-category-bullets-v3`)
  - 학습 데이터: 60 examples  
  - 최종 train loss: **0.6497** (v2 1.11 대비 큰 폭 개선)  
  - 토크나이저/모델 로드는 Hugging Face에서 1회 다운로드 후 캐시 사용
- v4 학습 (`results_bullets/qwen2.5-3b-lora-category-bullets-v4`)
  - 학습 데이터: 200 examples  
  - 토크나이저는 **이전 학습(v3)에서 저장한 로컬 토크나이저**를 재사용해 프록시 의존 최소화  
  - 최종 train loss: **0.2338** 로 추가 개선  
  - 학습 로그
    - epoch 0.8 시점: loss 0.5183  
    - epoch 1.56 시점: loss 0.0625  
    - epoch 2.0 평균 train_loss: 0.2337

---

#### 5) 추론 파이프라인 및 폴백 전략 점검

- `21_generate_category_bullets.py`
  - **모델 경로 기반 추론**: `--model_dir`에 LoRA 디렉토리(v3/v4)를 넘기면  
    - `training_metadata.json` 에서 `base_model` 을 읽거나 인자로 지정  
    - 베이스 모델 + LoRA 어댑터 로딩 → 채팅 템플릿(prompt) 생성 → `model.generate(...)` 실행
  - **템플릿-only 모드**: `--template_only` 옵션 시 모델 로드 없이 `build_category_summary_bullets` 로 바로 불릿 생성
  - 프록시/Windows 환경 대응
    - 스크립트 시작 시 `HTTP_PROXY`/`HTTPS_PROXY` 환경변수 제거
    - 모델/토크나이저는 최대한 로컬 캐시/로컬 디렉토리에서 로드
- JSON 파싱/검증 & 폴백
  - 모델 출력에서 첫 JSON 객체만 안전하게 파싱 (`_extract_json`)  
  - `summaryBullets` 필드 존재 여부와 타입(리스트/문자열)을 검증 (`_validate_result`)  
  - 매출/판매 관련 단어가 포함된 불릿은 환각 가능성이 높다고 판단해 템플릿으로 폴백  
  - 파싱/검증 실패 시: **템플릿 기반 불릿을 다시 생성해서 반환**
- 현재 관찰된 모델 출력(v3/v4 공통)
  - 예: `{"summaryB bullets": [...], ...}` 처럼 필드명이 깨져 있거나  
    - 한국어/중국어/HTML 태그가 뒤섞인 문자열 배열이 나와 JSON 스키마를 벗어남  
  - 그 결과, 실제 서비스용 최종 JSON은 **항상 템플릿 폴백 경로**에서 생성되는 상태

---

### 생성된/갱신된 주요 파일

| 파일명 | 역할 |
|--------|------|
| `ai_report_bullets_lib.py` | 카테고리 집계/불릿 템플릿 로직, 세그먼트 추출(`top_segments`) 추가 |
| `19_prepare_category_bullet_sft.py` | 카테고리별 SFT 학습 데이터(JSONL) 생성, 서브샘플링/샘플 수 파라미터화 및 시스템 프롬프트 강화 |
| `20_train_category_bullet_lora.py` | Qwen2.5-3B + LoRA 학습(v3, v4), 토크나이저 로컬 재사용 및 오류 메시지 정교화 |
| `21_generate_category_bullets.py` | LoRA 기반 카테고리 불릿 추론 + 템플릿-only 모드 + JSON 파싱/검증/폴백 및 디버깅 로그 강화 |
| `results_bullets/qwen2.5-3b-lora-category-bullets-v3` | 60개 샘플로 재학습된 LoRA 어댑터(+토크나이저, 메타데이터) |
| `results_bullets/qwen2.5-3b-lora-category-bullets-v4` | 200개 샘플로 재학습된 LoRA 어댑터(+토크나이저, 메타데이터) |

---

### 실행/검증 결과 요약

- `21_generate_category_bullets.py --model_dir ...v3/v4 --category_id 4`
  - 베이스 모델 및 LoRA 어댑터 로딩 정상 (Qwen2.5-3B, 2 shards)  
  - 모델 출력은 JSON 스키마를 어겨 항상 파싱 실패  
    - 예: `{"categoryId": X, "summaryB bullets": [...], ...}`  
    - 일부 문장에 HTML 태그와 다국어(중국어 포함) 혼재
  - 파싱 실패를 감지하면 템플릿으로 폴백  
  - 최종 출력 JSON 예시는 아래와 같이 **안정적**:
    - 상품/브랜드/누적리뷰  
    - 리뷰 0건 비중, 평점 및 1~2점 비중  
    - 가격 중앙값 + P25~P75, 최근 6개월 가격 변화 중앙값  
    - 상위 채널(리뷰 분포 기준), 상위 브랜드 및 집중도  
    - 자주 언급된 키워드, 업데이트 기간
- `21_generate_category_bullets.py --template_only --category_id 4`
  - 모델 없이도 동일한 형식의 `summaryBullets` JSON 생성 확인  
  - 운영 환경에서 **가장 안정적인 기본 모드**로 사용 가능

---

### 정리

#### 성과

- 카테고리 요약 불릿을 **고정 템플릿 + 근거 명시 문장**으로 정리해, UI에 바로 붙일 수 있는 수준까지 품질을 끌어올림
- `specifications` / `unit_price` 기반의 세그먼트 추출 구조를 마련해 “유망 세그먼트” 라인을 추가할 수 있는 기반 확보
- SFT 학습 데이터(4 → 60 → 200 examples)와 LoRA 재학습(v3, v4)을 통해 **모델이 과제 도메인을 이해할 수 있는 기반**을 마련
- 모델 출력이 불안정한 상황에서도, 템플릿 폴백을 통해 **항상 안정적인 JSON 불릿을 반환하는 추론 파이프라인** 완성

#### 한계/이슈

- v3/v4 모두 모델 출력이 여전히 JSON 스키마를 제대로 따르지 못함  
  - 필드명/타입 깨짐, 다국어 혼재, HTML 태그 포함 등  
  - 현재는 템플릿 폴백에 전적으로 의존하는 구조 (모델은 디버깅/연구용)
- 학습 데이터 카테고리가 4개로 제한되어 있어, 모델이 다양한 카테고리/표현 패턴을 일반화하기에는 여전히 부족
- Windows + 8GB GPU 환경에서는 여전히 메모리/페이징 파일 설정에 민감하므로, 운영 환경 이전 시 **메모리 스펙 및 가상 메모리 설정**이 중요

---

### 다음 단계 계획

#### 1) 모델 출력 형식 안정화 (JSON 스키마 학습)

- 학습 데이터에 “잘못된 JSON 예시 → 올바른 JSON 수정” 형태의 보정 데이터 추가 (필요 시)  
- 시스템 프롬프트를 한 번 더 정교화
  - 예: “`categoryId` 포함 금지, `summaryBullets`만 출력”  
  - HTML 태그·다국어 사용 금지, 숫자/단위 표기 예시 구체화
- 학습 데이터 규모를 조금 더 늘리되, 템플릿 불릿과 최대한 동일한 톤/형식을 유지하도록 생성

#### 2) 세그먼트 불릿 실제 사용 및 튜닝

- `top_segments` 내용이 풍부해지는 카테고리(예: 유아/유아식/장난감 등)를 중심으로  
  - “유망 세그먼트” 문장을 실제 템플릿에 노출해보고  
  - 어떤 표현/세그먼트 조합이 가장 직관적인지 튜닝

#### 3) 백엔드 연동(MVP) 및 옵션화

- 백엔드(Node.js)에서 먼저 **`--template_only` 모드**로 API 연동  
  - 실서비스에서는 항상 템플릿 JSON을 반환하도록 구성해 안정성 확보
- GPU/메모리 스펙이 충분한 환경이 준비되면
  - `mode=template` / `mode=model+fallback` 옵션으로 단계적 전환  
  - 모델 모드 사용 시에도, 현재와 같이 **JSON 파싱 실패 → 템플릿 폴백** 구조를 유지해 안전망 확보

---

### 기술 스택

- **데이터**: `products_all.csv` (상품 + 리뷰 요약 컬럼, unit_price, specifications 포함)
- **모델(학습)**: `Qwen/Qwen2.5-3B-Instruct` + LoRA(PEFT)  
  - v3: 60 examples, train_loss ≈ 0.65  
  - v4: 200 examples, train_loss ≈ 0.23
- **프레임워크**: Transformers, Datasets, Accelerate, PyTorch, PEFT
- **언어/환경**: Python 3.11, Windows(PowerShell)
- **추론 경로**:  
  - 모델 모드: `21_generate_category_bullets.py --model_dir ... --category_id ...`  
  - 템플릿 모드: `21_generate_category_bullets.py --template_only --category_id ...`

